// Generated by CoffeeScript 1.12.7
(function() {
  var BaseConfig, FrontendConfig, _, autoprefixer, fs, postcssFilenamePrefix, url, webpack,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  fs = require('fs');

  _ = require('lodash');

  autoprefixer = require('autoprefixer');

  postcssFilenamePrefix = require('postcss-filename-prefix');

  webpack = require('webpack');

  BaseConfig = require('./base');

  url = require('url');

  module.exports = FrontendConfig = (function(superClass) {
    extend(FrontendConfig, superClass);

    function FrontendConfig() {
      var base, base1, ref, ref1, ref2, ref3, ref4;
      FrontendConfig.__super__.constructor.apply(this, arguments);
      _.defaults(this.options, {
        stylus: {},
        frontend: {}
      });
      if (process.env.DEVSERVER_URL) {
        this.options.webpackPort = url.parse(process.env.DEVSERVER_URL).port || process.env.DEVSERVER_PORT || 80;
      }
      if ((base = this.options).webpackPort == null) {
        base.webpackPort = process.env.DEVSERVER_PORT || 3010;
      }
      if ((base1 = this.options).webpackUrl == null) {
        base1.webpackUrl = process.env.DEVSERVER_URL || ("http://localhost:" + this.options.webpackPort);
      }
      if (!this.options.apps) {
        this.options.apps = ['app'];
      }
      this.apps = this._sanitizeApps(this.options.apps);
      this.beforeStylusEntries = this._getBeforeStylusEntries();
      this.config.target = 'web';
      this.config.entry = this._getEntries(this.apps, this.options.frontend.baseEntry);
      this.config.module.loaders = this.config.module.loaders.concat([
        {
          include: /racer-highway\/lib\/browser\/index\.js$/,
          loaders: [__dirname + '/../loaders/racer-highway-loader.js']
        }
      ]);
      if ((((ref = this.options.frontend) != null ? ref.loaders : void 0) != null) && _.isArray(this.options.frontend.loaders)) {
        this.config.module.loaders = this.options.frontend.loaders.concat(this.config.module.loaders);
      }
      if ((((ref1 = this.options.frontend) != null ? ref1.preLoaders : void 0) != null) && _.isArray(this.options.frontend.preLoaders)) {
        this.config.module.preLoaders = this.options.frontend.preLoaders.concat(this.config.module.preLoaders || []);
      }
      if ((((ref2 = this.options.frontend) != null ? ref2.postLoaders : void 0) != null) && _.isArray(this.options.frontend.postLoaders)) {
        this.config.module.postLoaders = this.options.frontend.postLoaders.concat(this.config.module.postLoaders || []);
      }
      if (((ref3 = this.options.frontend) != null ? (ref4 = ref3.resolve) != null ? ref4.alias : void 0 : void 0) != null) {
        this.config.resolve.alias = this.options.frontend.resolve.alias;
      }
      this.config.output = {
        path: this.options.dirname + '/build/client',
        pathInfo: true,
        publicPath: "http://localhost:" + this.options.webpackPort + "/build/client/",
        filename: '[name].js'
      };
      this.config.plugins = this.config.plugins.concat([new webpack.NormalModuleReplacementPlugin(/\.(server|server\.coffee|server\.js)$/, require.resolve('node-noop'))]);
    }

    FrontendConfig.prototype._getHeaderEntry = function() {
      return ['racer-highway/lib/browser', 'derby-parsing'];
    };

    FrontendConfig.prototype._getBeforeStylusEntries = function() {
      var appName, beforeStyl, entry, ref, res;
      res = {};
      ref = this.apps;
      for (appName in ref) {
        entry = ref[appName];
        entry = _.isArray(entry) ? entry[0] : entry;
        beforeStyl = entry + '/styles/before.styl';
        if (fs.existsSync(beforeStyl)) {
          res[entry] = beforeStyl;
        }
      }
      return res;
    };

    FrontendConfig.prototype._getPostCss = function(plugins) {
      var DEFAULT_POSTCSS_PLUGINS;
      if (plugins == null) {
        plugins = [];
      }
      DEFAULT_POSTCSS_PLUGINS = [
        autoprefixer({
          browsers: ['last 2 version', '> 1%', 'ie 10', 'android 4']
        })
      ];
      if (this.options.moduleMode) {
        DEFAULT_POSTCSS_PLUGINS.push(postcssFilenamePrefix());
      }
      if (!_.isArray(plugins)) {
        plugins = [plugins];
      }
      return function() {
        return DEFAULT_POSTCSS_PLUGINS.concat(plugins);
      };
    };

    FrontendConfig.prototype._getStylusParams = function() {
      var DEFAULT_STYLUS;
      DEFAULT_STYLUS = {
        'include css': true
      };
      return _.merge({}, this.options.stylus, DEFAULT_STYLUS);
    };

    FrontendConfig.prototype._getActualStylusLoader = function(params) {
      var strStylusParams;
      if (params == null) {
        params = {};
      }
      params = _.merge({}, this._getStylusParams(), params);
      strStylusParams = JSON.stringify(params);
      return "raw!postcss!stylus?" + strStylusParams;
    };

    FrontendConfig.prototype._getBeforeStylusLoaders = function() {
      var beforeStyl, entry, ref, results;
      ref = this.beforeStylusEntries;
      results = [];
      for (entry in ref) {
        beforeStyl = ref[entry];
        results.push((function(_this) {
          return function(entry) {
            return {
              test: function(absPath) {
                return /\.styl$/.test(absPath) && absPath.indexOf(entry) !== -1;
              },
              loader: _this._getActualStylusLoader({
                "import": [beforeStyl]
              })
            };
          };
        })(this)(entry));
      }
      return results;
    };

    FrontendConfig.prototype._getStylusLoader = function() {
      return (function(_this) {
        return function(beforeStylusEntries) {
          var item, result, stylusImports;
          stylusImports = _this.options.stylusImports;
          result = (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = stylusImports.length; i < len; i++) {
              item = stylusImports[i];
              if (item.test) {
                results.push((function(_this) {
                  return function(arg) {
                    var _import, test;
                    test = arg.test, _import = arg["import"];
                    return {
                      test: function(absPath) {
                        var beforeStyl, entry, shouldCompiled;
                        if (!/\.styl$/.test(absPath)) {
                          return false;
                        }
                        shouldCompiled = true;
                        for (entry in beforeStylusEntries) {
                          beforeStyl = beforeStylusEntries[entry];
                          if (absPath.indexOf(entry) !== -1) {
                            shouldCompiled = false;
                            break;
                          }
                        }
                        return shouldCompiled && new RegExp(test).test(absPath);
                      },
                      loader: _this._getActualStylusLoader({
                        "import": _import
                      })
                    };
                  };
                })(this)(item));
              }
            }
            return results;
          }).call(_this);
          result.push({
            test: function(absPath) {
              var beforeStyl, entry, shouldCompiled, test;
              if (!/\.styl$/.test(absPath)) {
                return false;
              }
              shouldCompiled = true;
              for (entry in beforeStylusEntries) {
                beforeStyl = beforeStylusEntries[entry];
                if (absPath.indexOf(entry) !== -1) {
                  shouldCompiled = false;
                  break;
                }
              }
              shouldCompiled && (function() {
                var i, len, results;
                results = [];
                for (i = 0, len = stylusImports.length; i < len; i++) {
                  item = stylusImports[i];
                  if (test = item.test) {
                    if (new RegExp(test).test(absPath)) {
                      shouldCompiled = false;
                      break;
                    } else {
                      results.push(void 0);
                    }
                  }
                }
                return results;
              })();
              return shouldCompiled;
            },
            loader: _this._getActualStylusLoader()
          });
          return result;
        };
      })(this)(this.beforeStylusEntries);
    };

    return FrontendConfig;

  })(BaseConfig);

}).call(this);
